import { isFunction, isString } from './type-check';

/**
 * Ensure class prefix ends in `-`
 * @param {string} prefix The prefix to prepend to the class names generated by nano-css
 * @return {string} The prefix ending in `-`
 */
export function normalizePrefix(prefix) {
  if (!isString(prefix) || prefix === '') {
    return '';
  }

  return prefix.charAt(prefix.length - 1) !== '-' ? `${prefix}-` : prefix;
}

/**
 * Resolves attachTo options, converting element option value to a qualified HTMLElement.
 * @param {Step} step The step instance
 * @returns {[{}]|[{element, on}]}
 * `element` is a qualified HTML Element
 * `on` is a string position value
 */
export function parseAttachTo(step) {
  if (!step.options.attachTo) return [{ element: undefined }];
  const options = Array.isArray(step.options.attachTo)
    ? step.options.attachTo
    : [step.options.attachTo] || [];
  const returnOpts = [...options];

  returnOpts.forEach((_element) => {
    // Just do what we already do when it's a single element
    if (isFunction(_element.element)) {
      // Bind the callback to step so that it has access to the object, to enable running additional logic
      _element.element = _element.element.call(step);
    }

    if (isString(_element.element)) {
      // Can't override the element in user opts reference because we can't
      // guarantee that the element will exist in the future.
      try {
        _element.element = document.querySelector(_element.element);
      } catch (e) {
        // TODO
      }
      if (!_element.element) {
        console.error(
          `The element for this Shepherd step was not found ${_element.element}`
        );
      }
    }
  });
  return returnOpts;
}

/**
 * Checks if the step should be centered or not. Does not trigger attachTo.element evaluation, making it a pure
 * alternative for the deprecated step.isCentered() method.
 * @param resolvedAttachToOptions
 * @returns {boolean}
 */
export function shouldCenterStep(resolvedAttachToOptions) {
  if (
    resolvedAttachToOptions === undefined ||
    resolvedAttachToOptions === null
  ) {
    return true;
  }

  return !resolvedAttachToOptions.element || !resolvedAttachToOptions.on;
}

/**
 * Create a unique id for steps, tours, modals, etc
 * @return {string}
 */
export function uuid() {
  let d = Date.now();
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = (d + Math.random() * 16) % 16 | 0;
    d = Math.floor(d / 16);
    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);
  });
}
